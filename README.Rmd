---
output:
  github_document:
    toc: true  
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE, warning = FALSE, message = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  cache = TRUE,
  message = FALSE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "40%"
)

set.seed(124)
  
library(relper)
library(dplyr)
library(lubridate)
library(ggplot2)

df_date <-
  tibble(date = seq.Date(from = today(),
                         to = today() + days(5),
                         by = "1 day"))

```

# Intro

The goal of relper is to provide miscellaneous functions to assist in data cleaning and visualization.

# Installation

You can install the developer version of relper with:

``` r
remotes::install_github("vbfelix/relper")
```

# Functions

## "as_" functions

This functions convert values to another type.

### as_num
The goal of **as_num** is to be a version of `as.numeric`, where the input is a string number with marks, such as "10.000,02".

```{r as_num}
as_num("123.456,78")
```
### as_perc
The goal of **as_perc** is to compute a number as percentage. By default the function will just multiply values by 100.

```{r as_perc}
mtcars %>% 
  count(vs,am) %>% 
  mutate(prop = n/sum(n)) %>% 
  mutate(perc = as_perc(prop))
```

If you set the parameter **sum** to `TRUE` the function will divide the values by their total and multiply by 100.

```{r as_perc-sum}
mtcars %>% 
  count(vs,am) %>% 
  mutate(perc = as_perc(n,sum = TRUE))
```

## "calc_" functions

This functions compute a certain value.

### calc_acf

The goal of **calc_acf** is to compute the auto-correlation function, given by:

$$\frac{\sum_\limits{t = k+1}^{n}(x_t - \bar{x})(x_{t-k} - \bar{x})}{\sum_\limits{t = 1}^{n} (x_t - \bar{x})^2 },$$
where:

 - $x_t$ is a time series of length $n$;
 - $x_{t-k}$ is a shifted time series by $k$ units in time;
 - $\bar{x}$ is the average of the time series.

```{r calc_acf}
x <- rnorm(100)

calc_acf(x)

```

If you pass a second vector in the parameter `y` the cross-correlation will be computed instead:

$$\frac{n \left( \sum_\limits{t = 1}^{n}x_ty_t \right) - \left[\left(\sum_\limits{t = 1}^{n}x_t \right) \left(\sum_\limits{t = 1}^{n}y_t\right) \right]}{\sqrt{\left[n \left( \sum_\limits{t = 1}^{n}x_t^2 \right) - \left( \sum_\limits{t = 1}^{n}x_t \right)^2\right]\left[n \left( \sum_\limits{t = 1}^{n}y_t^2 \right) - \left( \sum_\limits{t = 1}^{n}y_t \right)^2\right]}},$$
where:

 - $x_t$ is a time series of length $n$;
 - $y_t$ is a time series of length $n$.

```{r calc_acf-ccf}
y <- rexp(100)

calc_acf(x,y)

```

### calc_auc

The goal of **calc_auc** is to compute the area under a curve (AUC).

```{r calc_auc-data}
x <- seq(-3,3,l = 100)

y <- dnorm(x)
```

```{r calc_auc-base-plot, echo = F}
ggplot(tibble(x = x,
              y = y),
       aes(x,y))+
  geom_point()+
  plt_theme_y()
```


```{r calc_auc-99}
#from min to max of x
range(x)

calc_auc(x,y)
```

```{r calc_auc-plot-99, echo = F}
df_auc <-
  tibble(
    x = x,
    y = y)

df_auc %>% 
ggplot(aes(x,y))+
  geom_area(alpha = .7, fill = "chocolate2")+
  geom_point()+
  plt_theme_y()+
  annotate("text",
           x = mean(x),y = mean(y),label = round(calc_auc(x,y),3),
           fontface = "bold", size = 7)+
  geom_vline(xintercept = c(-3,3), linetype = "dashed")+
  scale_x_continuous(breaks = -5:5)+
  scale_y_continuous(expand = c(0,0))
```

You can define the parameter `limits` to get the AUC of that limit.

```{r calc_auc-95}
#from -2 to 2
calc_auc(x,y,limits = c(-2,2))
```

```{r calc_auc-plot-95, echo = F}
df_auc %>% 
  ggplot(aes(x,y))+
  geom_area(data = df_auc %>% 
              filter(between(x,-2,2)),
              alpha = .7, fill = "chocolate2")+
  geom_point()+
  plt_theme_y()+
  annotate("text",
           x = mean(x),y = mean(y),label = round(calc_auc(x,y,limits = c(-2,2)),3),
           fontface = "bold", size = 7)+
  geom_vline(xintercept = c(-2,2), linetype = "dashed")+
  scale_x_continuous(breaks = -5:5)+
  scale_y_continuous(expand = c(0,0))
```

```{r calc_auc-68}
#from -1 to 1
calc_auc(x,y,limits = c(-1,1))
```

```{r calc_auc-plot-68, echo = F}
df_auc %>% 
  ggplot(aes(x,y))+
  geom_area(data = df_auc %>% 
              filter(between(x,-1,1)),
              alpha = .7, fill = "chocolate2")+
  geom_point()+
  plt_theme_y()+
  annotate("text",
           x = mean(x),y = mean(y),label = round(calc_auc(x,y,limits = c(-1,1)),3),
           fontface = "bold", size = 7)+
  geom_vline(xintercept = c(-1,1), linetype = "dashed")+
  scale_x_continuous(breaks = -5:5)+
  scale_y_continuous(expand = c(0,0))
```

### calc_corr
The goal of **calc_corr** is to compute Pearson, Kendall and Spearman correlation coefficients.

```{r calc_corr}
x <- rnorm(100)

y <- rnorm(100)

calc_corr(x,y)
```


### calc_cramers_v

The goal of **calc_cramers_v** is to compute Cramer's V, given by:

$$\sqrt{\frac{X^2}{n\min(r-1,c-1)}},$$
where:

  - $X^2$ the chi-square statistic;
  - $n$ is the sample size;
  - $r$ is the number of rows in the contingency table;
  - $c$ is the number of columns in the contingency table.

```{r calc_cramers_v}
m <- matrix(c(12, 5, 7, 7), ncol = 2)

chi_square <- chisq.test(m)

calc_cramers_v(chi_square)
```

### calc_cv
The goal of **calc_cv** is to compute the coefficient of variation (CV), given by:

$$\frac{s}{\bar{x}},$$
where:

 - $s$ is the sample standard deviation;
 - $\bar{x}$ is the sample mean.
 
```{r calc_cv}
set.seed(123);x <- rnorm(100,1)

calc_cv(x)
```

If you set the parameter `as_perc` to `TRUE`, the CV will be multiplied by 100.

```{r calc_cv-as-perc}
calc_cv(x,as_perc = TRUE)
```

### calc_date_aux

The goal of **calc_date_aux** is to compute variables derived from date, such as year, month, day, etc.

```{r calc_date_aux}
dt <- seq(as.Date("1910/1/1"), as.Date("1911/1/1"), "days")

df_dt <- data.frame(dt = dt)

calc_date_aux(df_dt,dt) %>% glimpse()
```

The new variables respective to the date are:

 - **mon_abb:** a factor with the abbreviated name of the month;
 - **mon_lbl:** a factor with the complete name of the month;
 - **mon_num:** the number of the month;
 - **day_num:** the number of the day within the month;
 - **year_num:** the number of the year;
 - **year_lbl:** a factor with the number of the year;
 - **week_num:** the number of complete seven day periods that have occurred between the date and January 1st, plus one;
 - **epiweek_num:** the US CDC version of epidemiological week. Starts on Sunday;
 - **isoweek_num:**  the week as it would appear in the ISO 8601 system, which uses a reoccurring leap week. Starts on Monday;
 - **wday_abb:** a factor with the week day abbreviated name;
 - **wday_lbl:** a factor with the week day complete name.
 
### calc_date_diff

The goal of **calc_date_diff** is to compute the difference between two dates.

```{r calc_date_diff}
date1 <- lubridate::dmy("01/05/1998")

date2 <- lubridate::dmy("21/11/2018")

calc_date_diff(date1 = date1,date2 = date2,unit = "days")
```

So, the difference in day of 21/11/2018 and 01/05/1998 is 7,509 days.

If you need to add a constant to your difference you can use the parameter `add`.

```{r calc_date_diff-add}
calc_date_diff(date1 = date1,date2 = date2,unit = "days",add = 1)
```

### calc_date_range

The goal of **calc_date_range** is to compute the range of a date vector, and create a string with the minimal and maximum date.

```{r calc_date_range}
dt <- seq(as.Date("1910/1/1"), as.Date("1911/1/1"), "days")

calc_date_range(dt)
```


### calc_geometric_mean

The goal of **calc_geometric_mean** is to compute the geometric mean, given by:

$$\sqrt[n]{\prod\limits_{i=1}^{n}x_i} = \sqrt[n]{x_1\times x_2 \times...\times x_n},$$
where:

 - $x_i$ is a numeric vector of length $n$.

```{r calc_geometric_mean}
calc_geometric_mean(x)
```

### calc_harmonic_mean

The goal of **calc_harmonic_mean** is to compute the harmonic mean, given by:

$$\frac{n}{\sum\limits_{i=1}^{n}\frac{1}{x_i}},$$
where:

 - $x_i$ is a numeric vector of length $n$.

```{r calc_harmonic_mean}
calc_harmonic_mean(x)
```

### calc_mean

The goal of **calc_mean** is to compute the arithmetic, geometric and harmonic mean.

```{r calc_mean}
calc_mean(x)
```

### calc_mode

The goal of **calc_mode** is to compute the mode.

```{r calc_mode-data}
set.seed(123);cat_var <- sample(letters,100,replace = TRUE)

table(cat_var)

```
We can see that the letter "*y*" is the one that appears the most, so it is the mode of the variable.

```{r calc_mode}
calc_mode(cat_var)
```

### calc_peak_density
The goal of **calc_peak_density** is to compute the peak density value of a numeric value.

```{r calc_peak_density-base-plot,echo = F}

ggplot2::ggplot(data = dplyr::tibble(x = x),
                ggplot2::aes(x))+
  ggplot2::geom_density()+
  relper::plt_theme_y()+
  ggplot2::scale_x_continuous(breaks = 0:20)

```

Let's say we eant to discover what value is the peak in the density above.

```{r calc_peak_density}
calc_peak_density(x)
```

```{r calc_peak_density-plot,echo = F}
ggplot2::ggplot(data = dplyr::tibble(x = x),
                ggplot2::aes(x))+
  ggplot2::geom_density()+
  ggplot2::geom_vline(xintercept = relper::calc_peak_density(x),col = "royalblue4", size = 1)+
  relper::plt_theme_y()+
  ggplot2::scale_x_continuous(breaks = 0:20,sec.axis = sec_axis(~.,breaks = round(relper::calc_peak_density(x),3)))

```

## "format_" functions

This functions modify an existing variable for aesthetic reasons.

### format_digit
The goal of **format_digit** is to add zero(s) on the left of a number.

```{r format_digit}

x <- c(1,4,10,12,100,2000)

format_digit(x)

```
You can also set the parameter `digits` to add more zeros.

```{r format_digit-digits}

format_digit(x,digits = 4)

```
### format_num

The goal of **format_num** is to add markers to a number.

```{r format_num}
format_num(12345.67)
```

You can also change the markers for other characters of your choice.

```{r format_num-markers}
format_num(12345.67,decimal_mark = "*",thousand_mark = "#")
```
Also, if you are Brazilian like me, I made a argument to make our lives easier.

```{r format_num-br}
format_num(12345.67,br_mark = TRUE)
```


### format_scale
The goal of **format_scale** is to reescale a variable, given by:

$$y_i = (y_{\max} - y_{\min}) * \left[\frac{x_i - \min(x_i)}{\max(x)-\min(x)} \right] + y_{\min},$$
where:

  - $y_i$ is the reescaled numeric vector;
  - $y_{\max}$ is the new maximum value, after the reescale;
  - $y_{\min}$ is the new minimum value, after the reescale;
  - $x_i$ is the original numeric vector;
  - $\min(x_i)$ is the original minimum value of $x_i$;
  - $\max(x_i)$ is the original maximum value of $x_i$.
  
By default the vector will be reescaled to have 0 and 1 as their new minimum and maximum values.  

```{r format_scale}

x <- seq(-3,3,l = 10)

x

y <- format_scale(x)

y
```

```{r format_scale-plot, echo = F}
plot(x,y)
```

You can also change the range of the new scale.

```{r format_scale-range}

z <- format_scale(x,new_min = 25,new_max = 100)

```

```{r format_scale-range-plot, echo = F}

plot(x,z)

```

### format_p_value

The goal of **format_p_value** is to change a p value, by considering a minimal value where if is minor than it, let's say 0.001, the p value will be changed to *<0.001*

```{r format_p_value}
format_p_value(c(.001,.00000001),p_value_min = 0.001)
```

## "is_" functions

This functions return a boolean, given a condition.

### is_even

The goal of **is_even** is to check if a value is even.

```{r is_even}
is_even(1)

is_even(2)

is_even(1.1)

is_even(2.2)

```

### is_negative

The goal of **is_negative** is to check if a value is negative.

```{r is_negative}
is_negative(1)

is_negative(-1)

```

### is_odd

The goal of **is_odd** is to check if a value is odd.

```{r is_odd}
is_odd(1)

is_odd(2)

is_odd(1.1)

is_odd(2.2)

```

### is_outlier

The goal of **is_outlier** is to check if a value is an outlier, by using the boxplot outlier criteria, given by:

$$ [x < (Q_1 - 1.5 * IQR)] \quad  |  \quad [x > (Q_3 - 1.5 * IQR)],$$

where:

 - $Q_1$ is the first quartile;
 - $Q_3$ is the third quartile;
 - $IQR$ is the interquartile range, e.g., $Q_3-Q_1$.

```{r is_outlier}
x <- c(1,2,3,5,7,8,12,100)

is_outlier(x)

```

### is_positive

The goal of **is_positive** is to check if a value is positive.

```{r is_positive}
is_positive(1)

is_positive(-1)

```

### is_string

The goal of **is_string** is to check if a value is a string, character or factor.

```{r is_string}
is_string("A")

is_string(factor("A"))

```

## "isnot_" functions

This functions will check if a variable does not pass a certain condition.

### isnot_in

The goal of **isnot_in** is to check if a variable is not contained, it is the same as `!(x %in% y)`.

```{r isnot_in}
isnot_in("a", letters)
```

### isnot_na

The goal of **isnot_na** is to check if a variable is not a `NA` it is the same as `!is.na(x)`.

```{r isnot_na}
isnot_na(2)

isnot_na(NA)
```

## "plt_" functions

This functions are extensions to **ggplot2** objects.

```{r plt-base}
library(ggplot2)

plot <- 
ggplot(mtcars,aes(qsec,mpg))+
  geom_point()

plot
```

### plt_flip_y_title

The goal of **plt_flip_y_title** is to flip the title from y axis, to be read horizontally.

```{r plt_flip_y_title}
plot + plt_flip_y_title
```

### plt_identity_line

The goal of **plt_identity_line** is to add a identity line to a scatter plot.

```{r plt_identity_line}
plot + plt_identity_line(color = "red")
```

### plt_no_background

The goal of **plt_no_background** is to remove the background.

```{r plt_no_background}
plot + plt_no_background
```

### plt_no_labels

The goal of **plt_no_labels** is to remove all labels.

```{r plt_no_labels}
plot + plt_no_labels
```

### plt_scale_auto

The goal of **plt_scale_auto** is to add a automatic scale.

```{r plt_scale_auto}
plot + plt_scale_auto(axis = "x",n = 5)
```

```{r plt_scale_auto-x-y}
plot +
  plt_scale_auto(axis = "x",n = 5)+
  plt_scale_auto(axis = "y",n = 3)
```

### plt_theme_map

The goal of **plt_theme_map** is to add a theme appropriate for a map.

```{r plt_theme_map}
plot + plt_theme_map()
```

### plt_theme_x

The goal of **plt_theme_x** is to remove major and minor grid lines from y axis.

```{r plt_theme_x}
plot + plt_theme_x()
```

### plt_theme_xy

The goal of **plt_theme_xy** is to remove minor grid lines from x and y axis.

```{r plt_theme_xy}
plot + plt_theme_xy()
```

### plt_theme_y

The goal of **plt_theme_y** is to remove major and minor grid lines from x axis.

```{r plt_theme_y}
plot + plt_theme_y()
```

### plt_water_mark

The goal of *plt_water_mark* is to add a image as a watermark in a ggplot2 object.

```{r plt_water_mark}
plot + plt_water_mark(png_file = vfx_watermark)
```

In the function above we use a .png file already imported in the R environment, but it is also possible to import a local file, providing the argument *png_path* instead.

## "str_" functions

This functions manipulate strings.

### str_clean

The goal of **str_clean** is to remove punctuation and/or accent.

```{r str_clean}
string <- "a..;éâ...íõ"

#remove only punctuation
str_clean(string,remove_accent = FALSE,remove_punct = TRUE)

#remove only accent
str_clean(string,remove_accent = TRUE,remove_punct = FALSE)

#remove both
str_clean(string)
```

### str_keep

The goal of **str_keep** is to keep only a type of character in the string.

```{r str_keep}
string <- "1Aa45Z89$$%#"

str_keep(string,keep = "text")

str_keep(string,keep = "numbers")

str_keep(string,keep = "special")
```

### str_select

The goal of **str_select** is to select part of a string, before, after or between patterns.

```{r str_select}
string <- "example text STRING1 TARGET STRING2 example text"

#Select a string, before a pattern
str_select(string,before = "STRING2")

#Select a string, after a pattern
str_select(string,after = "STRING1")

#Select a string, between two patterns
str_select(string,"STRING1","STRING2")
```

### str_to_abb

The goal of **str_to_abb** is to apply uppercase to strings with a number of characters lower than the argument `n_char` (default = 3).

```{r str_to_abb}
abcde_string <- c("aaaaa","bb","ccc","dddd")

str_to_abb(abcde_string,n_char = 3)
```

## "summary_" functions

This functions will summarize data and return metrics related to them.

### summary_cat

The goal of **summary_cat** is to summarize categorical variables.

```{r summary_cat}
x <- c(sample(letters,100,replace = TRUE),NA)

summary_cat(x)
```

### summary_data

The goal of **summary_data** is to summarize all variables from data.

```{r summary_data}
summary_data(mtcars)
```

### summary_num

The goal of **summary_num** is to summarize numeric variables.

```{r summary_num}
x <- c(rnorm(10),NA,10)

summary_num(x)
```

### summary_seq

The goal of **summary_seq** is to compute the number of sequential repeated values.

```{r summary_seq}

y <- c(1, 1, 1, 2, 2, 2, 2, 3, 4, 5, 6, 7, 1, 1)

summary_seq(y)

```

## "tbl_" functions

This functions show data in an table.

<!-- ### tbl_format_num -->

<!-- The goal of **tbl_format_num** is to apply **format_num** to all numeric variables in a data.frame. -->

<!-- ```{r tbl_format_num} -->
<!-- mtcars %>% -->
<!--    count(vs,am) %>% -->
<!--    tbl_format_num(digits = 5) -->
<!-- ``` -->

<!-- ### tbl_print -->

<!-- The goal of **tbl_print** is to print a data.frame as a plot. -->

<!-- ```{r tbl_print} -->
<!-- df <- data.frame(grp = c("a","b","c"), -->
<!--                  freq = c(2,4,6)) -->

<!-- tbl_print(df,bold_last = TRUE,header_col = "red") -->
<!-- ``` -->


### tbl_two_cat

The goal of **tbl_two_cat** is to create a frequency table with chi-square statistic, p-value and Cramer's V.

```{r tbl_two_cat,eval = FALSE}
mtcars %>%
  mutate(vs = paste0("vs = ",vs)) %>%
  tbl_two_cat(grp_var = vs,vars = c(am,cyl))
```


```{r tbl_two_cat-plot, echo = FALSE}

png_tbl_two_cat <- 
  mtcars %>%
  mutate(vs = paste0("vs = ",vs)) %>%
  tbl_two_cat(grp_var = vs,vars = c(am,cyl))

gt::gtsave(
  png_tbl_two_cat,
  "tbl_two_cat.png",
  vwidth = 1500,
  vheight = 1000)

```

### tbl_two_num

The goal of **tbl_two_num** is to create a summary table comparing one or more numerical variables between two groups.

```{r tbl_two_num,eval = FALSE}

tbl_two_num(
  df = df,
  grp_var = grp_var,
  num_vars = c(num_var1,num_var2,num_var3),
  method = c("auto")
)

```

```{r tbl_two_num-plot, echo = FALSE}
set.seed(123);df <-
  data.frame(
    grp_var = sample(paste("group", letters[1:2]),size = 100,replace = TRUE),
    num_var1 = rnorm(100),
    num_var2 = rpois(100,2),
    num_var3 = rexp(100,2),
   num_var4 = abs(rnorm(100))
  )

table <- 
tbl_two_num(
  df = df,
  grp_var = grp_var,
  num_vars = c(num_var1,num_var2,num_var3),
  method = c("auto")
)

gt::gtsave(table, "tbl_two_num.png", vwidth = 1500, vheight = 1000)

```




## Other functions

### cut_by_quantile

The goal of **cut_by_quantile** is to cut a numeric variable by a set of quantiles.

```{r cut_by_quantile}
x <- rnorm(100)

table(cut_by_quantile(x,q = seq(0,1,by = .25)))
```

### expand_grid_unique

The goal of **expand_grid_unique** is to create a grid of all combination from two variables, with no repetition.

```{r expand_grid_unique}
expand_grid_unique(x = 1:3,y = 1:3)
```

You can also set the parameter `include_equals` to `TRUE` so equal pairs are kept.

```{r}
expand_grid_unique(x = 1:3,y = 1:3, include_equals = TRUE)
```

### obj_to_string

The goal of **obj_to_string** is to return the name of an R object as a string.

```{r obj_to_string}
x <- c(1,2,3,5,7,8,12,100)

obj_to_string(x)

```



### row_number_unique

The goal of **row_number_unique** is to get the row number but considering the unique values
of a variable.

```{r row_number_unique}
mtcars %>% 
  select(vs,gear) %>% 
  slice(1:10) %>% 
  group_by(vs) %>% 
  mutate(gear_position = row_number_unique(gear))
```

### rpearson

The goal of **rpearson** is to simulate data, where two variables will be linear correlated with a normal distribution, using pearson correlation coefficient as a parameter.

```{r rpearson}
set.seed(123);df <- rpearson(n = 100, pearson = .8, mean = 3)

df %>% 
  ggplot(aes(x,y))+
  geom_point()+
  geom_smooth(method = "lm", se = FALSE)
```

